#!/bin/bash

CURRENT_DIR="$(dirname "$(readlink -f "$0")")"
source $CURRENT_DIR/../lib/moniotr-constants

TRAFFIC_DIR_BY_ALL="$TRAFFIC_DIR/by-all"

ME=$(basename $0)

if [[ $# -eq 0 ]] || [[ "$1" == "help" ]]; then
    echo "This script extracts MITM traffic previously generated by the specified network device and"
    echo "printes the results (if any) to the standard output."
    echo
    echo "Usage: $ME <DEVICE_ID> <NETWORK_NAME> <PROTOCOL> [<TIME_INITIAL>] [<TIME_FINAL>]"
    echo
    echo "DEVICE_ID     Device identifier. It can be either a MAC Address, an IP Address, or the"
    echo "              name of the device."
    echo
    echo "NETWORK_NAME  Experiment identifier. Only consider the type of experiment among $NETWORK_NAMES."
    echo
    echo "PROTOCOL      Protocol to be extracted. It can be either \"http\" or \"https\"."
    echo
    echo "TIME_INITIAL  Unix timestamp (without fractional part) of the initial time to consider."
    echo "              MITM traffic before this timestamp will be ignored."
    echo "              If this parameter is not specified, a timestamp 0 is used."
    echo
    echo "TIME_FINAL    Unix timestamp (without fractional part) of the final time to consider."
    echo "              MITM traffic after this timestamp will be ignored."
    echo "              If this parameter is not specified the current timestamp is used."
    echo
    echo "Example: $ME 11:22:33:44:55:66 unctrl http 11111111 11111200"
    exit
fi

ID="$1"
NETWORK_NAME="$2"
PROTOCOL="$3"
TIME_I="$4"
TIME_F="$5"
TIME_NOW=`date +%s`

if [ $# -le 2 ]; then
    >&2 echo "$ME: Insufficient number of arguments."
    >&2 echo "For more information: $ME help"
    exit
fi

if [[ ! -d "$TRAFFIC_DIR_BY_ALL/$ID" ]] ; then
    >&2 echo "$ME: ID '$ID' not found. ID must be the MAC addrress, IP address, or name of a registered device."
    >&2 echo "For more information: $ME help"
    exit
fi

MAC=`cat "$TRAFFIC_DIR_BY_ALL/$ID/$MAC_FILE"`
NAME=`cat "$TRAFFIC_DIR_BY_ALL/$ID/$NAME_FILE"`
IP=`cat "$TRAFFIC_DIR_BY_ALL/$ID/$IP_FILE"`

for network_name in $NETWORK_NAMES; do
    if [[ "$network_name" == "$NETWORK_NAME" ]]; then
        network_name_found="ok"
    fi
done

if [[ "$network_name_found" != "ok" ]]; then
    >&2 echo "$ME: NETWORK_NAME '$NETWORK_NAME' not found. NETWORK_NAME must be among $NETWORK_NAMES."
    >&2 echo "For more information: $ME help"
    exit
fi

if [[ "$PROTOCOL" != "http" ]] && [[ "$PROTOCOL" != "https" ]]; then
    >&2 echo "$ME: PROTOCOL '$PROTOCOL' not found. PROTOCOL must be either \"http\" or \"https\"."
    >&2 echo "For more information: $ME help"
    exit
fi

if [ $# -le 4 ]; then
    TIME_F=$TIME_NOW
fi

if [ $# -le 3 ]; then
    TIME_I=0
fi

if [[ ! "$TIME_F" =~ ^-?[0-9]+$ ]] || [[ "$TIME_F" -gt "$TIME_NOW" ]]; then
    >&2 echo "$ME: TIME_FINAL not valid. It must be a valid unix timestamp that is not in the future."
    >&2 echo "For more information: $ME help"
    exit
fi

if [[ ! "$TIME_I" =~ ^-?[0-9]+$ ]] || [[ "$TIME_I" -gt "$TIME_F" ]]; then
    >&2 echo "$ME: TIME_INITIAL not valid. It must be a valid unix timestamp smaller than TIME_FINAL."
    >&2 echo "For more information: $ME help"
    exit
fi

TIME_I_DATE=`date -d @$TIME_F +'%Y-%m-%d'`
TIME_F_DATE=`date -d @$TIME_F +'%Y-%m-%d'`

for FILE in $TRAFFIC_DIR_BY_ALL/$MAC/$NETWORK_NAME/$PROTOCOL-*; do

    if [ ! -f "$FILE" ]; then
        continue;
    fi

    if [[ ! "$FILE" =~ $PROTOCOL-([1-9][0-9][0-9][0-9])-([0-1][0-9])-([0-2][0-9]).log ]]; then
        continue;
    fi

    DAY=${BASH_REMATCH[3]##0}
    MONTH=${BASH_REMATCH[2]##0}

    if [[ ${BASH_REMATCH[1]} -le 0 ]] || [[ $MONTH -le 0 ]] || [[ $DAY -le 0 ]] || [[ $MONTH -ge 13 ]] || [[ $DAY -ge 32 ]]; then
        continue;
    fi

    FILE_DATE=${BASH_REMATCH[1]}-${BASH_REMATCH[2]}-${BASH_REMATCH[3]}
    FILE_TS_I=`date -d $FILE_DATE +%s`
    FILE_TS_F=$((FILE_TS_I+86399))

    if [[ $TIME_F -lt $FILE_TS_I ]] || [[ $TIME_I -gt $FILE_TS_F ]]; then
        continue;
    fi

    while read line; do
        if [[ $line =~ ([1-9][0-9]+)\..* ]]; then
            line_time=${BASH_REMATCH[1]}
            if [[ ! -z $line_time ]] && [[ $line_time -ge $TIME_I ]] && [[ $line_time -le $TIME_F ]]; then
                echo $line
            fi
        fi
    done < $FILE
done
